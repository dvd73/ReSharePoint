<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="SiteFeatures" xml:space="preserve">
    <value>&lt;h2&gt;SPMeta2 is now part of &lt;a href="http://subpointsolutions.com/"&gt;SubPoint Solutions&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://subpointsolutions.com/"&gt;SubPoint Solutions&lt;/a&gt; is an inovative company that helps SharePoint professionals and consultancy companies be efficient. &lt;/p&gt;

&lt;p&gt;We look after &lt;a href="http://subpointsolutions.com/spmeta2/about"&gt;SPMeta2 library&lt;/a&gt;, &lt;a href="http://subpointsolutions.com/spcafcontrib/about"&gt;SPCAFContrib&lt;/a&gt; and a few more projects aim to provide a powerful foundation and experience for SharePoint professionals. &lt;/p&gt;

&lt;p&gt;With growing demaind of effective SharePoint artifact provision for SP2013 and O365, we are taking &lt;a href="http://subpointsolutions.com/spmeta2/about"&gt;SPMeta2 library&lt;/a&gt; to the next level, offering &lt;a href="http://subpointsolutions.com/spmeta2/sdk"&gt;SPMeta2 SDK&lt;/a&gt; and &lt;a&gt;additional support&lt;/a&gt; for our clients.&lt;/p&gt;

&lt;p&gt;Learn more about &lt;a href="http://subpointsolutions.com/spmeta2/about"&gt;SPMeta2 library&lt;/a&gt;, stay tuned with &lt;a href="https://www.yammer.com/spmeta2feedback/"&gt;SPMeta2 Yammer Group&lt;/a&gt; and &lt;a href="https://subpointsolutions.uservoice.com/"&gt;let us know how it works for you&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;What is SPMeta2?&lt;/h2&gt;

&lt;p&gt;SPMeta2 is a fluent API for code-based SharePoint artifact provisioning.&lt;/p&gt;

&lt;p&gt;Struggling with SharePoint's API inconsistency, bugs, &amp;quot;by-design&amp;quot; behaviour, unaffordable amount of time to write, support and upgrade WSP packages and XML, a team of passionate SharePoint professionals decided to come up with robust, testable and repeatable way to deploy such artifacts like fields, content types, libraries, pages and many more.&lt;/p&gt;

&lt;p&gt;As an outcome, we created SPMeta2 - a .NET 4.5 library to provide fluent API for SharePoint 2013 artifact with SSOM/CSOM or JSOM for both on premise and O365 instances. Have a look around, check out get started links and more details about SPMeta. &lt;/p&gt;

&lt;h2&gt;Get started!&lt;/h2&gt;

&lt;table style="color: #222222; height: 125px;" width="483"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign="top" width="50%"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="http://docs.subpointsolutions.com/spmeta2"&gt;About&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="http://docs.subpointsolutions.com/spmeta2/features"&gt;Features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="http://docs.subpointsolutions.com/spmeta2/releases"&gt;Releases and roadmap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="http://docs.subpointsolutions.com/spmeta2/provision"&gt;How-to artefact provision&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="https://www.nuget.org/profiles/SubPointSupport"&gt;SPMeta2 @ Nuget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="https://github.com/SubPointSolutions/spmeta2.contoso"&gt;SPMeta2.Contoso - sample projects&lt;/a&gt;&lt;/li&gt;&lt;a style="color: #006adf" href="https://github.com/SubPointSolutions/spmeta2.contoso"&gt;
&lt;/a&gt;&lt;/ul&gt;&lt;a style="color: #006adf" href="https://github.com/SubPointSolutions/spmeta2.contoso"&gt;
&lt;/a&gt;&lt;/td&gt;
&lt;td valign="top" width="50%"&gt;
&lt;ul&gt;

&lt;li&gt;&lt;a style="color: #006adf" href="http://docs.subpointsolutions.com/spmeta2/license"&gt;License&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="http://subpointsolutions.com/services/support"&gt;Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="https://subpointsolutions.uservoice.com/"&gt;Feature requests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style="color: #006adf" href="https://www.yammer.com/spmeta2feedback/"&gt;SPMeta2 Yammer Group&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;SPMeta2 philosophy and mission&lt;/h2&gt;

&lt;h3&gt;Fluent API and syntax extensions&lt;/h3&gt;

&lt;p&gt;SPMeta2 API allows you to define SharePoint artifacts such as field, content type, list (and many more), define relationships between them and, finally, deploy them via SSOM/CSOM. You work with c# POCO objects defining your data model, we take care about the rest. &lt;/p&gt;

&lt;p&gt;SPMeta2 might be extended with custom syntax implementation to meet your project needs. Extension methods are used to adjust a specific behavior or property of SharePoint artifacts. Custom syntax or DSL can easily be created to address specific project needs.&lt;/p&gt;

&lt;p&gt;Learn more here - &lt;a href="http://docs.subpointsolutions.com/spmeta2/how-it-works/"&gt;How SPMeta2 Works&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Model tree build-in validation&lt;/h3&gt;

&lt;p&gt;The model tree might be optionally validated with build in rules. It guarantees nobody adds a field to the web or list to the site collection. Custom validators can be implemented to address your project needs as well. &lt;/p&gt;

&lt;p&gt;Builtin validators ensure SharePoint limitations and boundaries. SPMeta2 checks that internal names of all your fields don not exceed 32 chars. There is more magic than you can imagine.&lt;/p&gt;

&lt;h3&gt;SharePoint 2013 Foundation, Standard, Enterprise and O365 are supported&lt;/h3&gt;

&lt;p&gt;SPMeta2 supports all SharePoint editions. It is splitted up into several packages to reflect SharePoint editions: Foundation, Standart and Enterprise. O365 support is implemented with CSOM.&lt;/p&gt;

&lt;h3&gt;SSOM and CSOM are supported. JSOM is coming up.&lt;/h3&gt;

&lt;p&gt;SPMeta2 supports SSOM and CSOM. We are working on JSOM support implemeted with TypeScript and SPTypeScript.&lt;/p&gt;

&lt;p&gt;[sourcecode language='csharp'][TestMethod]
        [TestCategory(&amp;quot;Regression.Scenarios.ListItemValue&amp;quot;)]
        public void CanDeploy&lt;em&gt;ListItemValue&lt;/em&gt;ById()
        {
            try
            {
                WithListItemValue((listItem, fieldDefs) =&amp;gt;
                {
                    foreach (var fieldDef in fieldDefs)
                    {
                        listItem.AddListItemFieldValue(new ListItemFieldValueDefinition
                        {
                            FieldId = fieldDef.Id,
                            Value = Rnd.String()
                        });
                    }
                });
            }
            catch (SPMeta2NotSupportedException ex)
            {
                Assert.IsTrue(ex.Message.Contains(&amp;quot;ListItemFieldValueDefinition.FieldId&amp;quot;));
            }
        }[/sourcecode]&lt;/p&gt;

&lt;h3&gt;No XML inside - only code&lt;/h3&gt;

&lt;p&gt;SPMeta2 is code based provision library for SharePoint 2013.
* You DO NOT write XML
* You DO NOT write WSP
* You DO write code instead&lt;/p&gt;

&lt;p&gt;Learn more here - &lt;a href="http://docs.subpointsolutions.com/spmeta2/how-it-works/"&gt;How SPMeta2 Works&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Regression and testing are implemented and supported&lt;/h3&gt;

&lt;p&gt;Having code based provision allows us to have full control over the provision and update flow. As there is no WSP or XML, not features need to be deployed or activated. &lt;/p&gt;

&lt;p&gt;This allows us to write integration tests within minutes, make sure deployment and upgrade work as expected. Most of the provision cases are covered with integration tests. We create a new site or web, deploy everything we need and check if everything has been deployed correctly.&lt;/p&gt;</value>
  </data>
</root>